\section{Aufgabe 1}
Bearbeiten Sie die folgenden Aufgaben und protokollieren Sie Ihr Vorgehen mit-
hilfe der Vorlage.
Implementieren Sie ein C-Programm, das folgende Anforderungen erfüllt:
\begin{itemize}
	\item Eine Datei wird zum Lesen geöffnet; anschließend wird zuerst die zweite
	Hälfte und dann die erste Hälfte des Dateiinhalts auf dem Bildschirm ausgegeben.
	\item  Danach wird der Inhalt der Datei in eine neue Datei kopiert, wobei der Dateiname der
Quell- und der Zieldatei dem Programm als Argument übergeben	werden kann.
\item  Die letzten 10 Zeichen der ursprünglichen Datei werden ab der 11. Stelle der neuen Datei
kopiert. Das Dateiende der neuen Datei soll jetzt nach den verschobenen Daten sein (also
nach dem 21. Zeichen).
\item Der Inhalt der Datei soll auf dem Bildschirm ausgegeben werden.


\end{itemize}

	\subsection{Vorbereitung}
	Für Testzwecke erstellen wir eine Datei mit Text (gefüllt mit generiertem text)
	\textit{filetocopy} und \textit{testtarget}
	\subsection{Durchführung}
	\begin{itemize}
		\item Damit wir Dateinamen als Argumente an unser Programm übergeben können, definieren wir in der
		main Function die Parameter \command{main(int argc, char *argv[])}. Der Parameter
		\command{argc} beinhaltet die Anzahl der übergebenen Argumente + 1 (Programm Name) und
		\command{argv} beinhaltet alle übergebenen Argumente. Ab Index 1 können wir auf die Argument Liste
		zugreifen. Als erstes Argument erwarten wir den Pfad zur Quelldatei und als zweites Argument erwarten wir
	den Pfad zur Zieldatei. Die darauffolgenden Argumente werden ignoriert.
	\item wir prüfen ob genug Argumente übergeben wurden, wenn nicht, dann bricht das Programm ab.
	\item wenn alle benötigten Argumente vorhanden sind führt das Programm fort.
	\item wir definieren zwei Variablen, wo wir die Pfade für Quell- und Zieldatei speichern.
	\begin{lstlisting}
char * quellpath;
char * zielpath;
\end{lstlisting}


Zudem definieren wir Variablen die den Quell- respektive den Zielstream halten,
\begin{lstlisting}
int filedescriptorQuelle;
int filedescriptorZiel;
\end{lstlisting}

Diese werden in den Methoden \command{read}, \command{write},
\command{close} benutzt um die Datei mit der gearbeitet wird zu spezifizieren.

\item Für beide Dateien definieren wir jeweils eine Variable Modus.
Dies sorgt dafür dass die Quelle
im Lesemodus geöffnet wird.
Das Ziel soll sowohl im Lese- als auch im Schreibmodus geöffnet werden.

\begin{lstlisting}
mode_t modeQuelle = S_IRUSR;
mode_t modeZiel = S_IRUSR | S_IWUSR;
\end{lstlisting}

\item Für Beide Dateien definieren wir jeweils Variable, die Länge der Datei speichert
\begin{lstlisting}
long long quellsize;
long long targetsize;
\end{lstlisting}

\item Als nächsten Schritt überprüfen wir die Anzahl der übergebenen Argumente.
Wurden nicht genügend Parameter übergeben, also nicht Quelle und Ziel, so soll
das Programm abbrechen. Zuvor übermitteln wir mittels \command{perror} den Fehler
über den \command{stderr} Output Stream.

\begin{lslisting}
	if (argc <= 2){
		perror("Error: too few arguments");
		exit(EXIT_FAILURE);
	}
\end{lslisting}

\item Nun ermitteln wir den absoluten Pfad anhand der Eingaben des Users.
Konnte der Pfad nicht aufgelöst werden, also z.b. wenn die Datei nicht
gefunden werden konnte, so müssen wir das Programm abbrechen.
Dazu prüfen wir den Rückgabeparameter von \command{realpath}.
Ist dieser NULL, so existiert die Datei nicht und wir geben den Fehler
aus.
Hierbei ist anzumerken dass der Eingabeparameter eine beliebige Fehleranmerkung
ist. \command{perror} gibt nämlich den mit dem in \command{errno} hinterlegten
Fehlercode aus.
\begin{lslisting}
	if(realpath(argv[1], quellpath) == NULL){
		perror("Error argv[1]:");
		exit(EXIT_FAILURE);
	}
\end{lslisting}

\end{itemize} %end first lvl itemize%



	\subsection{Fazit}

\newpage
